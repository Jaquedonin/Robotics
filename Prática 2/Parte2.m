%%fprintf("Parte 2 Pratica 2")%%%%function [obstacles, xf, yf]=gertraj(res)%% defina o ponto de partida e chegada:%Init=[1.39;1.67];Init=[1;6.2];Goal=[8;1];%% Mapa normal para OcupancyGridimage = imread('mapaexemploCorreto.bmp');grayimage = rgb2gray(image);bwimage = grayimage < 0.5;grid = robotics.BinaryOccupancyGrid(bwimage,50);show(grid)%figure%% Infla o OcuppancyGrid maprobotRadius = 0.15;mapInflated = copy(grid);inflate(mapInflated,robotRadius);%%matriz = occupancyMatrix(mapInflated);Wo=15;matrix=flip(matriz*Wo);%%xf=0:0.01995555556:8.98; %450yf=0:0.01994444444:7.18-0.01994444444; %360[X,Y] = meshgrid(xf,yf);%%KA=15;rG2=KA*sqrt((Goal(1)-X).^2+((Goal(2)-Y).^2));Weight=rG2+matrix;% Comando original: surf(xf,yf,Weight)C = Weight;surf(xf,yf,Weight,  'edgecolor', 'none');%surf(xf,yf,Weight)colorbar%figure%% Identifica os obstáculos da parede como círculos[mx, my]=size(matrix);cnt=1;for y=1:7:mx    for x=1:7:my        if matrix(y,x)==15        obstacles{cnt}=[x*0.01995555556 y*0.01994444444 robotRadius];        plot(obstacles{cnt}(1), obstacles{cnt}(2), 'o')        hold on        cnt=cnt+1;        end    endendcnt=cnt-1;%% Gerando a Trajetóriacurrent{1}=Init; %Diz que posição 1 é a inicial.k=1;       %Inicializa o contador de posiçãoka=0.1;    %Ganho da função de atraçãokr=0.01;   %Ganho da função de repulsãoDO = 0.2;  %limiar do obstáculodist=1;    %condição inicial do laço whilederivxO=0; %inicialização do gradiente X do obstaculoderivyO=0; %inicialização do gradiente Y do obstaculo%% figureshow(mapInflated)hold onplot(Goal(1),Goal(2),'bo');hold onplot(Init(1),Init(2),'bx');hold onfor i=1:1:cntplot(obstacles{i}(1),obstacles{i}(2),'ro');hold onend%%while (dist>=0.01)    for m=1:1:cnt        RobotObstacleDistance = sqrt(((current{k}(1)-obstacles{m}(1))^2) + ((current{k}(2)-obstacles{m}(2))^2)) - obstacles{m}(3);        if RobotObstacleDistance <= DO            derivxO=derivxO+kr*(current{k}(1)-obstacles{m}(1));            derivyO=derivyO+kr*(current{k}(2)-obstacles{m}(2));        end    end    dist=sqrt((Goal(1)-current{k}(1))^2+((Goal(2)-current{k}(2))^2));    derivx=ka*(Goal(1)-current{k}(1))/dist;    derivy=ka*(Goal(2)-current{k}(2))/dist;    current{k+1}(1)=current{k}(1)+(derivx+derivxO);%X    current{k+1}(2)=current{k}(2)+(derivy+derivyO);%Y    plot(current{k}(1),current{k}(2),'go');    hold on    if dist<=0.1        break;    end    k=k+1;end